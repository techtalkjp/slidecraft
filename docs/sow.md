# SlideCraft MVP 作業範囲記述書

## 作業の目的

本作業は、PDFスライドをアップロードしてAIで各ページを再生成できるWebアプリケーション「SlideCraft」の最小実用版を構築することを目的とする。referencesディレクトリのslidegeniusを参考としながら、React Router v7の型安全性、shadcn/uiの洗練されたUI、Vercel AI GatewayによるセキュアなAI統合を実現する。

ユーザーはブラウザ上でPDFをアップロードし、各スライドに対してプロンプトを入力することで視覚的改善案を生成できる。生成された複数の候補から選択して適用し、最終的に編集後のスライドデッキをPDFとしてエクスポートできる。全てのデータはブラウザのOrigin Private File Systemに保存され、作業の中断と再開が可能である。

## フェーズ1: 基盤構築

本フェーズでは、アプリケーション全体で使用する型定義とOPFSのユーティリティ関数を実装する。これらは後続の全ての機能実装の基礎となるため、最初に確実に動作することを確認する必要がある。

### 型定義の実装

`app/lib/types.ts`を作成し、アプリケーション全体で使用する型を定義する。Slide型はスライドの一意識別子としてUUIDを持ち、ページインデックス、最後に使用したプロンプト文字列を保持する。GeneratedImage型は生成された画像の識別子、使用したプロンプト、生成時刻をISO 8601形式で持つ。

画像データそのものは型定義に含めず、OPFSのファイルパスで参照する設計とする。これにより、メタデータと画像データを分離し、メモリ効率を向上させる。型定義ファイルにはJSDocコメントで各フィールドの目的と制約を記述する。

### OPFSユーティリティの実装

`app/lib/storage.client.ts`を作成し、OPFSへの読み書き操作を抽象化する関数群を実装する。このファイルは`.client.ts`拡張子を使用することで、クライアントサイドでのみバンドルされることを保証する。

getOpfsRoot関数は`navigator.storage.getDirectory()`を呼び出してOPFSのルートディレクトリハンドルを取得し、`slidecraft`サブディレクトリを作成または取得して返す。ensureDirectory関数はパスを受け取り、途中のディレクトリを全て作成する。writeFile関数はBlobまたはUint8Arrayを受け取り、指定パスにファイルを書き込む。readFile関数はパスからファイルを読み込みBlobとして返す。deleteFile関数とdeleteDirectory関数は指定パスのファイルまたはディレクトリを削除する。

全ての関数はPromiseを返し、エラー時には適切なエラーメッセージを含む例外をスローする。ブラウザがOPFSに対応していない場合は、機能検出を行い、わかりやすいエラーメッセージを表示する。

### スライドデータ永続化の実装

`app/lib/slides-repository.client.ts`を作成し、スライドデータの読み書きを担当するリポジトリ層を実装する。loadSlides関数は`/slidecraft/slides.json`を読み込み、JSON.parseでSlide配列に変換して返す。ファイルが存在しない場合は空配列を返す。

saveSlides関数はSlide配列を受け取り、JSON.stringifyで整形した後に`/slidecraft/slides.json`に書き込む。各スライドの画像データは別ファイルとして管理するため、JSONには画像データを含めない。

saveSlideImage関数はスライドID、画像タイプ（original、current、generated）、画像Blobを受け取り、`/slidecraft/images/{slideId}/{type}.png`または`/slidecraft/images/{slideId}/generated/{generatedId}.png`に保存する。loadSlideImage関数は対応するパスから画像Blobを読み込んで返す。

これらの関数により、上位層のコードは具体的なファイルパス構造を意識せずにスライドデータを操作できる。

## フェーズ2: PDFアップロード機能

本フェーズでは、ユーザーがPDFファイルをアップロードし、各ページを画像に変換してOPFSに保存する機能を実装する。この機能はアプリケーションの入り口であり、ユーザーが最初に体験する部分である。

### PDF処理ユーティリティの実装

`app/lib/pdf-processor.client.ts`を作成し、PDFをページごとの画像に変換する関数を実装する。pdf.jsライブラリを使用してPDFを読み込み、各ページをCanvasにレンダリングし、PNGとしてBlobに変換する。

convertPdfToSlides関数はPDFのFileオブジェクトを受け取り、各ページをレンダリングしてSlide配列を生成する。各スライドには一意のUUID、ページインデックス、空の生成候補配列を設定する。画像BlobはsaveSlidesImageを呼び出してoriginalとcurrentの両方として保存する。

レンダリング時の解像度は、スライドの用途を考慮して幅1920pxを基準とする。これにより、フルHDディスプレイでも十分な品質を確保しつつ、ファイルサイズを抑える。進捗状況をコールバックで通知できるようにし、UIでプログレスバーを表示できるようにする。

### アップロード画面の実装

`app/routes/index.tsx`にPDFアップロード画面を実装する。loaderでloadSlides関数を呼び出し、既存のスライドデータの有無を確認する。既存データがある場合はエディター画面へのリンクを表示し、ない場合はアップロードUIを表示する。

アップロードUIは、中央に配置された大きなドロップゾーンとファイル選択ボタンで構成する。ドラッグ&ドロップ対応のため、onDragOver、onDragLeave、onDropイベントハンドラを実装し、ドラッグ中は視覚的フィードバックとして背景色とボーダーを変化させる。

ファイルが選択されたら、convertPdfToSlidesを呼び出してスライドデータを生成し、saveSlidesで保存する。処理中はローディングインジケーターを表示し、進捗状況を数値で表示する。完了後はエディター画面にリダイレクトする。

エラーハンドリングとして、PDFファイル以外が選択された場合はアラートを表示し、PDF処理中のエラーはErrorBoundaryで捕捉してユーザーフレンドリーなメッセージを表示する。

### 必要なパッケージのインストール

pdfjs-distパッケージをインストールする。React Router v7のSSR環境でpdf.jsを使用するため、dynamic importを使用してクライアントサイドでのみ読み込むよう注意する。pdf.jsのworkerファイルもpublicディレクトリに配置し、適切にパスを設定する。

## フェーズ3: エディター基本レイアウト

本フェーズでは、スライドを閲覧・選択するための3カラムレイアウトのエディター画面を実装する。AI生成機能は後のフェーズで追加するため、ここでは基本的な表示と選択機能に集中する。

### エディター画面のルート実装

`app/routes/editor.tsx`を作成し、loaderでloadSlidesを呼び出してスライドデータを読み込む。スライドが存在しない場合はルートパスにリダイレクトする。各スライドの画像データはloaderでは読み込まず、コンポーネント側で必要に応じて遅延読み込みする。

現在選択中のスライドインデックスはURLのクエリパラメータ`?slide=0`として管理する。これにより、ブラウザの戻る・進む操作や、URLの共有・ブックマークが可能になる。デフォルトは0番目のスライドとする。

### サイドバーコンポーネントの実装

`app/routes/editor/+sidebar.tsx`にサイドバーコンポーネントを実装する。react-router-auto-routesの`+`プレフィックスを使用してコロケーションし、エディター専用のコンポーネントであることを明示する。

サイドバーは固定幅256pxで左端に配置し、スライドのサムネイル画像を縦スクロール可能なリストとして表示する。各サムネイルはLinkコンポーネントでラップし、クリックすると`?slide={index}`のクエリパラメータを更新する。

選択中のスライドは青色のリングで強調し、元画像から変更されたスライド（currentImageが存在するスライド）には小さな「編集済み」バッジを表示する。サムネイル画像はloadSlideImageを使用して遅延読み込みし、useEffectで画像データをdata URLに変換してimgタグのsrcに設定する。

### メインプレビューエリアの実装

`app/routes/editor/+main-preview.tsx`にメインプレビューエリアを実装する。中央の広い領域に現在選択中のスライドの画像を大きく表示する。画像はアスペクト比を保ちながら表示領域に収まるようにobject-fit: containを適用する。

画像の上部には、スライド番号と総ページ数を表示する。元画像に戻すボタンも配置するが、この段階ではまだ機能しない（フェーズ4で実装）。

### ヘッダーとレイアウトの実装

`app/routes/editor/+header.tsx`にヘッダーコンポーネントを実装する。高さ56pxの固定ヘッダーとして画面上部に配置し、アプリケーション名「SlideCraft」、読み込み済みスライド数、PDF書き出しボタンを配置する。書き出しボタンはこの段階では無効化しておく。

`editor.tsx`でこれらのコンポーネントを組み合わせ、flexboxを使用した3カラムレイアウトを構成する。ヘッダーは固定、サイドバーとメインエリアは残りの高さを分割し、それぞれスクロール可能にする。

## フェーズ4: API設定機能

本フェーズでは、ユーザーがGoogle Gemini APIキーを設定・管理する機能を実装する。これにより、ユーザーは自分のAPIキーを使用して画像生成を行える。

### API設定ユーティリティの実装

`app/lib/api-settings.client.ts`を作成し、APIキーの読み書きを行うユーティリティ関数を実装する。getApiKey関数はlocalStorageから`slidecraft:apiKey`を読み込み、存在すれば返す。saveApiKey関数はAPIキーをlocalStorageに保存する。clearApiKey関数はAPIキーを削除する。

localStorageを使用することで、ページリロード後もAPIキーが保持される。セキュリティ上の注意として、APIキーは暗号化せずに平文で保存するが、これはブラウザのlocalStorageの一般的な使用方法である。

### API設定画面の実装

`app/routes/settings.tsx`にAPI設定画面を実装する。中央にCardコンポーネントを配置し、APIキー入力フォームと保存ボタンを表示する。

フォームには、Google AI StudioでAPIキーを取得する方法を説明するリンクを含める。入力されたAPIキーは、保存ボタンを押すとsaveApiKeyで保存され、エディター画面にリダイレクトする。

loaderでgetApiKeyを呼び出し、既存のAPIキーがある場合は入力欄に表示する。これにより、ユーザーはAPIキーを確認・変更できる。

### ヘッダーへの設定ボタン追加

`app/routes/editor/+header.tsx`のヘッダーに設定ボタンを追加する。Keyアイコンを使用し、クリックすると`/settings`に遷移する。これにより、ユーザーはいつでもAPIキーを変更できる。

### APIキー未設定時の処理

`app/routes/editor.tsx`のloaderで、getApiKeyを呼び出してAPIキーの有無を確認する。APIキーが設定されていない場合は、`/settings`にリダイレクトする。これにより、APIキー未設定時は自動的に設定画面が表示される。

## フェーズ5: AI生成機能

本フェーズでは、プロンプトを入力してスライドのバリエーションを生成し、選択して適用する機能を実装する。この機能がアプリケーションの中核的な価値である。

### 右パネルコンポーネントの実装

`app/routes/editor/+control-panel.tsx`に右パネルコンポーネントを実装する。固定幅384pxで右端に配置し、上から順にプロンプト入力エリア、生成枚数選択、生成ボタン、生成結果の候補リストを配置する。

プロンプト入力はTextareaコンポーネントを使用し、4行程度の高さとする。生成枚数は1〜4枚のボタンで選択できるようにする。生成ボタンはクリックイベントハンドラーで処理し、クライアントサイドでAI生成を実行する。

生成結果の候補リストは2カラムのグリッドレイアウトでサムネイル表示する。各候補はボタンとしてクリック可能にし、選択するとそのスライドのcurrentGeneratedIdを更新する。現在適用中の候補にはチェックマークアイコンを表示する。

### Gemini API呼び出しユーティリティの実装

`app/lib/gemini-api.client.ts`を作成し、Google Gemini APIを直接呼び出す関数を実装する。@google/generative-aiパッケージを使用する。

generateSlideVariation関数は、APIキー、元画像のBlob、プロンプトを受け取り、Gemini APIに画像編集リクエストを送信する。画像はbase64エンコードして送信し、プロンプトと共にモデルに渡す。

レスポンスから生成された画像データを取得し、Blobとして返す。エラーハンドリングとして、APIキー不正、レート制限、ネットワークエラーなどを適切に捕捉し、わかりやすいエラーメッセージを返す。

### 画像生成処理の実装

右パネルコンポーネントで、生成ボタンのクリックハンドラーを実装する。ローカルステートでローディング状態を管理し、生成中はボタンを無効化してスピナーを表示する。

getApiKeyでAPIキーを取得し、loadSlideImageで元画像を読み込む。generateSlideVariation関数を呼び出し、生成された画像BlobをsaveSlideImageで保存する。新しいGeneratedImageオブジェクトを作成し、スライドのgeneratedCandidates配列に追加してsaveSlidesで保存する。

生成枚数分だけ上記の処理を繰り返す。進捗状況を表示するため、現在の生成枚数をステートで管理し、UIに反映する。

### 候補適用の実装

候補サムネイルをクリックしたときの処理を実装する。クリックされた候補のIDをスライドのcurrentGeneratedIdに設定し、saveSlidesで保存する。これにより、メインプレビューに選択した候補が表示される。

元に戻すボタンもクリックハンドラーを実装し、currentGeneratedIdをundefinedに設定することでoriginalImageを表示する。

### パッケージのインストール

@google/generative-aiパッケージをインストールする。これによりGoogle Gemini APIを簡単に呼び出せる。

## フェーズ6: PDFエクスポート機能

本フェーズでは、編集後のスライドを全て結合してPDFとしてダウンロードする機能を実装する。これによりユーザーは作業の成果物を保存できる。

### PDF生成ユーティリティの実装

`app/lib/pdf-generator.client.ts`を作成し、jsPDFライブラリを使用してスライド画像からPDFを生成する関数を実装する。generatePdfFromSlides関数はSlide配列を受け取り、各スライドのcurrentImageまたはoriginalImageをloadSlideImageで読み込む。

jsPDFインスタンスを作成し、最初のスライドの画像サイズからPDFのページサイズを計算する。一般的なスライドは16:9のアスペクト比なので、A4横向きまたはカスタムサイズとして設定する。

各スライドの画像をPDFの新しいページとして追加し、全てのスライドを処理したらBlobとして出力する。進捗状況をコールバックで通知できるようにする。

### エクスポート処理の実装

ヘッダーのエクスポートボタンにクリックハンドラーを実装する。ローカルステートでローディング状態を管理し、エクスポート中はボタンを無効化してスピナーを表示する。

loadSlidesですべてのスライドを読み込み、generatePdfFromSlidesを呼び出してPDF Blobを生成する。生成されたBlobをURL.createObjectURLでdata URLに変換し、非表示のaタグを作成してクリックすることでダウンロードを開始する。ファイル名は`slides-edited-${日付}.pdf`とする。

進捗状況をステートで管理し、UIに反映する。エラー発生時は適切なメッセージを表示する。

### jsPDFパッケージのインストール

jsPDFパッケージをインストールする。これによりブラウザ上でPDFを生成できる。

## フェーズ7: UI改善とエラーハンドリング

本フェーズでは、shadcn/uiのコンポーネントを使用してUIを洗練させ、エラーハンドリングを強化する。

### shadcn/uiコンポーネントのインストール

必要なshadcn/uiコンポーネントをインストールする。Button、Card、Textarea、Progress、Alert、Badgeなどを追加し、既存のプレーンなHTML要素を置き換える。

components.jsonの設定を確認し、エイリアス設定が正しく機能することを確認する。TailwindCSS v4のカスタムプロパティが適用されていることも確認する。

### アップロード画面のUI改善

ドロップゾーンをCardコンポーネントでラップし、影とボーダーを適用する。アップロードボタンをButtonコンポーネントに置き換え、variantとsizeを適切に設定する。

PDF処理中の進捗表示にProgressコンポーネントを使用し、処理済みページ数 / 総ページ数を視覚的に表示する。

### エディター画面のUI改善

サイドバーのサムネイルをCardコンポーネントでラップし、ホバー時のエフェクトを追加する。編集済みバッジをBadgeコンポーネントに置き換える。

右パネルのプロンプト入力をshadcn/uiのTextareaコンポーネントに置き換え、フォーカス時のリングカラーを統一する。生成ボタンをButtonコンポーネントに置き換え、ローディング中はスピナーアイコンを表示する。

生成結果の候補リストもCardコンポーネントでラップし、選択中の候補には異なるボーダーカラーを適用する。

### エラーバウンダリの実装

`app/routes/editor.tsx`にErrorBoundary exportを追加し、予期しないエラーをキャッチする。エラーメッセージとスタックトレースを表示し、ルートパスに戻るボタンを配置する。

`app/root.tsx`にも全体的なErrorBoundaryを追加し、アプリケーション全体のエラーをキャッチする。

### エラーメッセージの改善

AI生成失敗時のエラーメッセージを具体的にする。レート制限エラー、APIキー不正、ネットワークエラーなど、エラーの種類に応じて異なるメッセージと対処方法を表示する。

OPFS書き込み失敗時は、容量不足の可能性を示唆し、古い生成候補の削除を促す。削除機能は将来実装するため、ここでは手動削除の方法を案内する。

## 成果物

本作業の完了時点で以下のファイルが実装される。

### 型定義とユーティリティ

`app/lib/types.ts` - Slide型、GeneratedImage型の定義
`app/lib/storage.client.ts` - OPFS操作のユーティリティ関数
`app/lib/slides-repository.client.ts` - スライドデータの読み書きリポジトリ
`app/lib/pdf-processor.client.ts` - PDF→画像変換ユーティリティ
`app/lib/pdf-generator.client.ts` - 画像→PDF生成ユーティリティ
`app/lib/api-settings.client.ts` - APIキー管理ユーティリティ
`app/lib/gemini-api.client.ts` - Google Gemini API呼び出しユーティリティ

### ルートとコンポーネント

`app/routes/index.tsx` - PDFアップロード画面
`app/routes/settings.tsx` - API設定画面
`app/routes/editor.tsx` - エディター画面のルートとloader
`app/routes/editor/+header.tsx` - ヘッダーコンポーネント
`app/routes/editor/+sidebar.tsx` - サイドバーコンポーネント
`app/routes/editor/+main-preview.tsx` - メインプレビューコンポーネント
`app/routes/editor/+control-panel.tsx` - 右パネルコンポーネント

### 設定ファイル

`README.md` - セットアップ手順の追記

### shadcn/uiコンポーネント

`app/components/ui/button.tsx`
`app/components/ui/card.tsx`
`app/components/ui/textarea.tsx`
`app/components/ui/progress.tsx`
`app/components/ui/alert.tsx`
`app/components/ui/badge.tsx`

## 動作確認項目

各フェーズ完了時に以下の項目を確認する。

フェーズ1完了時: OPFSへのファイル書き込みと読み込みが正常に動作し、ブラウザの開発者ツールでストレージ内容を確認できること。型定義にエラーがなく、TypeScriptのtypecheckが通ること。

フェーズ2完了時: PDFをドラッグ&ドロップまたはファイル選択でアップロードでき、各ページが画像として変換されOPFSに保存されること。処理中に進捗バーが表示され、完了後にエディター画面に遷移すること。

フェーズ3完了時: エディター画面でスライド一覧がサイドバーに表示され、クリックするとメインエリアに大きく表示されること。選択中のスライドが強調表示されること。URLのクエリパラメータが正しく更新されること。

フェーズ4完了時: API設定画面でGemini APIキーを入力・保存でき、localStorageに保存されること。APIキー未設定時にエディター画面から設定画面にリダイレクトされること。ヘッダーの設定ボタンから設定画面にアクセスできること。

フェーズ5完了時: プロンプトを入力して生成ボタンを押すと、Google Gemini API経由で画像が生成されOPFSに保存されること。生成結果が候補リストに表示され、クリックするとメインプレビューに適用されること。元に戻すボタンが機能すること。

フェーズ6完了時: エクスポートボタンを押すと、現在のスライドが全てPDFとして結合され、ファイルがダウンロードされること。PDFを開いて各ページが正しく表示されること。

フェーズ7完了時: 全てのUIコンポーネントがshadcn/uiのスタイルで統一されていること。エラーが発生した際に適切なエラーメッセージが表示されること。ErrorBoundaryが機能すること。

## 技術的な注意事項

全てのクライアントサイド専用のコード（OPFS、pdf.js、jsPDF、Gemini API）は`.client.ts`拡張子を使用するか、dynamic importで読み込むこと。これによりSSR時のエラーを回避する。

React RouterのloaderはSSR対応のため、async/awaitを適切に使用し、エラーハンドリングをtry-catchで行うこと。クライアントサイドでのみ実行する処理はclientLoaderを使用する。

画像データは常にBlobとして扱い、data URLへの変換は表示時のみ行うこと。これによりメモリ使用量を削減する。

OPFSのファイルパスは全て`/slidecraft/`で始まるようにし、他のアプリケーションとの衝突を避けること。

Google Gemini APIキーはlocalStorageで管理し、ユーザーが自分で設定する方式とする。クライアントサイドから直接Gemini APIを呼び出すため、APIキーはクライアントに露出するが、これはユーザー自身のキーであるため問題ない。
