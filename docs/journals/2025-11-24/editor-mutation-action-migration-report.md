# Editor Mutation処理のclientAction移行分析

日付: 2025-11-24
対象: `/app/routes/_app/projects/$projectId/edit/`
目的: 現在のmutation実装をReact Router v7のclientActionで実装した場合の影響を評価

## エグゼクティブサマリー

SlideCraftのeditorページにおけるmutation処理をReact Router v7のclientActionパターンに移行することで、コードの明確性と保守性が大幅に向上します。ただし、完全移行には進捗表示の実装に関する重大な制約が存在します。このため、シンプルなmutation処理のみをclientActionに移行し、複雑な進捗管理を要する生成処理は現状の実装を維持するハイブリッドアプローチを推奨します。

現状の実装では、mutation処理がカスタムフックに集約されており、14個のuseStateによる状態管理が分散しています。clientActionに移行することで、これらの状態の大部分をfetcherに委譲でき、エラーハンドリングも統一されます。特に候補選択とリセット処理は、clientActionへの移行により型安全性とテスタビリティが向上します。

一方、生成処理は複数画像の生成中に詳細な進捗状態を表示する必要があります。現状では「修正中 2/4」のような表示が可能ですが、clientActionはリクエスト-レスポンスモデルのため途中経過を返せません。この制約により、生成処理の完全移行はユーザー体験を損なう可能性があります。

推奨するハイブリッドアプローチでは、候補選択とリセット処理をclientActionに移行し、生成処理は現状のuseSlideGenerationフックを維持します。この方式により、移行コストを8時間程度に抑えつつ、保守性と型安全性の恩恵を受けられます。

## 現状の実装分析

editorページのmutation処理は、現在3つの主要な操作から構成されています。候補画像の選択、AI生成による修正案の作成、オリジナル画像へのリセットです。これらの処理は、useSlideGenerationカスタムフックに集約されており、コンポーネントからはハンドラ関数として呼び出されます。

候補選択処理は最もシンプルな実装です。ユーザーが生成された候補画像をクリックすると、スライドのcurrentGeneratedIdフィールドが更新され、OPFSに保存されます。この処理は約18行のコードで実装されており、エラーハンドリングは基本的なtry-catchブロックのみです。エラーが発生した場合、generationErrorステートに文字列が設定されますが、UIへのエラー表示は一貫していません。

生成処理は最も複雑な実装であり、約120行のコードを要します。プロンプトのバリデーション、APIキーの確認、AI APIへのリクエスト、生成された画像のOPFSへの保存、メタデータの更新、Google Analytics 4へのトラッキングイベント送信という一連の処理が含まれます。この処理では、5つのuseStateフックによる状態管理が必要です。isGenerating(生成中フラグ)、generationProgress(進捗状態)、validationError(バリデーションエラー)、generationError(生成エラー)、showApiKeyDialog(APIキー入力ダイアログ表示フラグ)がそれぞれ管理されています。

generationProgressステートは特に重要です。複数枚の画像を生成する場合、現在何枚目を処理中かを「修正中 2/4」のような形式で表示します。この進捗表示により、ユーザーは処理の完了予測ができ、待機時間の不安が軽減されます。

リセット処理は最もシンプルで、約18行のコードです。currentGeneratedIdフィールドをundefinedに設定してOPFSに保存するだけです。エラーハンドリングはconsole.errorのみで、UIへのフィードバックはありません。

これらの処理全体で、状態管理は14個のuseStateに分散しています。ControlPanelコンポーネントがpromptとgenerationCountを管理し、useSlideGenerationが5つの状態を管理し、useSlideImagesが画像キャッシュを管理し、useCostEstimateがコスト計算を管理し、useImageZoomPanがズーム・パン機能を管理しています。この分散した状態管理により、データフローの把握が困難になっています。

## clientAction実装パターン

clientActionによる実装では、mutation処理をルートファイルからエクスポートされるaction関数に集約します。React Routerは自動的にこの関数を認識し、フォーム送信やプログラム的な呼び出しに応答します。

候補選択処理をclientActionで実装すると、約85行のコードになります。action関数内でスライドの取得、更新、保存を行い、成功時とエラー時で異なる戻り値を返します。コンポーネント側では、useFetcherフックを使用してactionを呼び出します。fetcher.Formコンポーネントにhidden inputフィールドを含め、\_action、slideId、generatedIdを送信します。fetcher.stateでローディング状態を監視し、fetcher.dataでactionの結果にアクセスします。

コード量は41行から85行に増加しますが、責任の分離が明確になります。action関数はビジネスロジックのみを担当し、コンポーネントはUI表示とフォーム送信のみを担当します。この分離により、action関数を独立してユニットテストできます。従来のカスタムフックのテストでは、React Testing LibraryのrenderHookを使用し、複数の依存をすべてモックする必要がありました。一方、action関数は純粋な非同期関数なので、FormDataを作成して関数を呼び出し、戻り値を検証するだけでテストできます。

エラーハンドリングも統一されます。すべてのaction関数でtry-catchを使用し、エラー時には`{ error: string }`形式のオブジェクトを返します。コンポーネント側では、`fetcher.data?.error`をチェックして統一されたUIでエラーを表示します。従来の実装では、各ハンドラ関数でエラーハンドリングのパターンが異なり、UIへの表示も一貫していませんでした。

型安全性も向上します。useFetcherに`typeof clientAction`を型引数として渡すことで、fetcher.dataの型が自動推論されます。action関数が`{ success: true, slideId: string }`を返す場合、TypeScriptはfetcher.data.slideIdが文字列であることを認識します。従来の実装では、状態の型を手動で定義する必要がありました。

## 生成処理における進捗表示の制約

生成処理をclientActionで実装する場合、最大の課題は進捗状態の管理です。現状の実装では、setGenerationProgressを呼び出すことで、UIに「修正中 2/4」のような詳細な進捗を表示できます。この進捗表示は、複数枚の画像生成に時間がかかる場合、ユーザーに処理状況を伝える重要な役割を果たします。

clientActionはリクエスト-レスポンスモデルに基づいています。action関数は一度だけ値を返し、完了します。途中経過を複数回返すことはできません。つまり、画像生成のループ処理中に進捗状態を返す方法がありません。fetcher.stateは「idle」「submitting」「loading」の3つの状態しか持たず、詳細な数値情報を含みません。

この制約を回避する方法として、Server-Sent Events(SSE)を使用してサーバーから進捗をストリーミングする案が考えられます。しかし、SlideCraftはクライアント側のOPFSを使用しており、サーバーを持ちません。SSEの実装には新たなサーバーインフラが必要になり、clientActionの利点を完全に損ないます。

別の回避策として、複数のfetcherを使用して各画像生成を個別に実行する案もあります。4枚の画像を生成する場合、4つのfetcherを作成し、それぞれ個別にactionを呼び出します。UI側で完了したfetcherの数を集計すれば進捗が分かります。しかし、この方式では並列実行の制御が難しく、APIレート制限にも対処できません。また、各actionが独立してスライドメタデータを更新するため、競合状態が発生する可能性があります。

最も現実的な解決策は、生成処理のみ現状のuseSlideGenerationフックを維持することです。進捗表示が重要な複雑な処理は従来の実装を保ち、シンプルなmutation処理のみclientActionに移行します。このハイブリッドアプローチにより、ユーザー体験を損なわずに、保守性の向上という恩恵を受けられます。

## 状態管理の削減

clientActionへの移行により、mutation関連の状態管理が大幅に削減されます。現状では、isGenerating、generationProgress、validationError、generationError、showApiKeyDialogの5つのuseStateがmutation処理に関連しています。

clientAction実装では、isGeneratingがfetcher.stateに置き換わります。fetcher.stateが「submitting」の場合は生成中、「idle」の場合は待機中です。従来のboolean型のフラグと異なり、fetcher.stateは「loading」状態も持つため、revalidation(loader再実行)中も区別できます。

validationErrorは不要になります。action関数内でバリデーションを実行し、エラー時は`{ error: 'プロンプトを入力してください' }`を返すだけです。コンポーネント側では、fetcher.data.errorをチェックして表示します。従来の実装では、バリデーションエラー専用のステートが必要でしたが、一般的なエラーと統一できます。

generationErrorもfetcher.data.errorに統合されます。action関数内のtry-catchで捕捉したエラーを`{ error: string }`形式で返すことで、バリデーションエラーと同じ方法で表示できます。従来は、バリデーションエラーとランタイムエラーで別々のステートを使用していました。

showApiKeyDialogは残ります。APIキーが未設定の場合、action関数が`{ error: 'apiKeyRequired' }`を返し、コンポーネント側でこの特殊なエラーを検知してダイアログを表示します。この処理はUI固有のロジックなので、ステートとして管理する必要があります。

generationProgressは、前述の通り、clientActionでは実装できません。この制約により、生成処理の完全移行は困難です。

結果として、mutation関連の状態が5個から1個(showApiKeyDialog)に削減されます。削減率は80%です。残りの9個のuseStateは、画像キャッシュ、コスト計算、ズーム・パンなど、mutation以外の機能に関連するものです。

## コードの明確性と責任の分離

現状の実装では、useSlideGenerationフックが120行のコードですべてを担当しています。バリデーション、APIキー確認、生成処理、画像保存、メタデータ更新、エラーハンドリング、GA4追跡が1つのフックに密結合しています。この構造では、一部の処理だけを変更したい場合でも、フック全体を理解する必要があります。

clientAction実装では、action関数とコンポーネントで責任が明確に分離されます。action関数はビジネスロジック(データの取得、更新、保存、外部API呼び出し)を担当し、コンポーネントはUI表示(フォームのレンダリング、ローディング状態の表示、エラーメッセージの表示)を担当します。この分離により、ビジネスロジックの変更とUI変更を独立して行えます。

action関数はルートファイルの+actions.tsxに集約されます。このファイルを開けば、すべてのmutation処理が一覧できます。従来の実装では、mutation処理がカスタムフック内に隠蔽されており、コンポーネントからは見えませんでした。+actions.tsxでは、\_actionフィールドによる分岐により、どのような操作が可能かが明確に分かります。

テスタビリティも大幅に向上します。従来のカスタムフックをテストするには、React Testing LibraryのrenderHookを使用し、10個の依存(projectId、slide、allSlides、onSlideUpdate、prompt、generationCount、loadCandidateImage、recordGenerationCost、resetGenerationCost)をすべてモックする必要がありました。テストコードは複雑になり、状態の検証も困難でした。

clientActionでは、action関数を純粋な非同期関数としてテストできます。FormDataを作成し、関数を呼び出し、戻り値を検証するだけです。成功ケース、バリデーションエラーケース、APIキー未設定ケース、ランタイムエラーケースを、それぞれ独立したテストとして記述できます。React環境やコンポーネントのマウントは不要です。

## エラーハンドリングの一貫性

現状の実装では、エラーハンドリングが分散しています。useSlideGenerationではgenerationErrorステートにエラーメッセージを設定し、GA4にトラッキングイベントを送信します。一方、+main-preview.tsxのリセット処理ではconsole.errorのみで、UIへのエラー表示がありません。candidate-images-gridの選択処理でもエラー表示が不十分です。エラーメッセージの形式もバラバラで、トラッキングの有無も一貫していません。

clientAction実装では、すべてのaction関数で統一されたエラー処理パターンを使用します。各action関数はtry-catchブロックを持ち、エラー時には必ず`{ error: string }`形式のオブジェクトを返します。成功時は`{ success: true, ...data }`形式です。この規則により、コンポーネント側で一貫したエラー表示が可能になります。

すべてのfetcherで同じUIコンポーネントを使用してエラーを表示します。fetcher.data?.errorをチェックし、存在すればAlertコンポーネントを表示します。AlertCircleアイコンとAlertDescriptionを使用することで、視覚的にも統一されます。ユーザーは、どのmutation操作でも同じスタイルでエラーを確認できます。

トラッキングも統一できます。各action関数のcatchブロックで、必要に応じてGA4イベントを送信します。生成処理ではtrackGenerationFailed関数を呼び出し、他の処理では省略するなど、処理の重要度に応じて統一されたパターンで実装できます。

## 型安全性の向上

現状の実装では、ハンドラ関数の戻り値はvoidです。エラー状態はuseStateで管理され、型は手動で定義されます。generationErrorの型は`string | null`ですが、どのようなエラー文字列が設定されるかは実装を読まなければ分かりません。

clientAction実装では、action関数の戻り値が自動で型推論されます。selectCandidateAction関数が`{ success: true, slideId: string, generatedId: string | null }`または`{ error: string }`を返す場合、TypeScriptはこの union型を自動的に推論します。

useFetcherに`typeof clientAction`を型引数として渡すことで、fetcher.dataの型が自動的に推論されます。`fetcher.data?.success`をチェックすると、TypeScriptは型ガードによりfetcher.data.slideIdとfetcher.data.generatedIdにアクセスできることを認識します。`fetcher.data?.error`をチェックすると、fetcher.data.errorが文字列であることを認識します。

この型推論により、リファクタリング時の安全性が向上します。action関数の戻り値を変更すると、コンポーネント側でコンパイルエラーが発生します。従来の実装では、ステートの型を手動で更新する必要がありました。

## Revalidationの自動化

現状の実装では、mutation処理が完了した後、手動でonSlideUpdate関数を呼び出しています。この関数は内部的にuseRevalidatorフックのrevalidateメソッドを実行し、loaderを再実行してUIを更新します。この手動呼び出しは、実装者が忘れるとUIが古いデータのままになるリスクがあります。

clientActionでは、action関数が値を返すと、React Routerが自動的にloaderを再実行します。これはRevalidationと呼ばれる機能で、mutation後のデータ同期を自動化します。実装者は何もする必要がありません。action関数内でOPFSにデータを保存し、成功オブジェクトを返すだけで、loaderが再実行され、最新のデータがUIに反映されます。

ただし、SlideCraftの現在の実装では、loaderがプロジェクトメタデータのみを読み込み、スライドデータは読み込んでいません。スライドデータはコンポーネント内で直接OPFSから読み込まれています。このため、現状ではRevalidationの恩恵を受けられません。将来的にloaderでスライドデータも読み込むように変更すれば、Revalidationにより完全な自動同期が実現します。

## 新機能追加の容易さ

現状の実装で新しいmutation処理を追加する場合、以下のステップが必要です。まず、useSlideGenerationフックにハンドラ関数を追加します。次に、必要に応じて新しいステート(useState)を追加します。エラーハンドリングを追加します。コンポーネントでフックの戻り値からハンドラを受け取ります。最後に、UIからハンドラを呼び出します。合計5ステップです。

clientAction実装では、2ステップで完了します。まず、+actions.tsxのclientAction関数に新しいケースを追加します。\_actionフィールドの値をチェックし、新しいaction関数を呼び出すif文を追加します。次に、コンポーネントでfetcher.Formを作成し、hidden inputに\_actionの値を設定します。これだけです。

ステート管理、エラーハンドリング、型定義はすべて既存のパターンを再利用できます。fetcher.stateでローディング状態を監視し、fetcher.data?.errorでエラーを表示します。新しいaction関数の戻り値は自動で型推論されます。

この簡潔さにより、機能追加のスピードが向上します。また、パターンが統一されているため、チームメンバー間での実装方法の差異も少なくなります。

## ハイブリッドアプローチの推奨

完全移行と現状維持の中間として、ハイブリッドアプローチを推奨します。候補選択処理とリセット処理をclientActionに移行し、生成処理は現状のuseSlideGenerationフックを維持します。

候補選択とリセットは、どちらも進捗表示が不要なシンプルな処理です。これらをclientActionに移行することで、エラーハンドリングの一貫性、型安全性、テスタビリティの恩恵を受けられます。実装もシンプルなので、移行リスクが低く、成功体験を得やすいです。

生成処理は進捗表示が重要なので、現状の実装を維持します。useSlideGenerationフックは120行程度ですが、詳細な進捗表示により優れたユーザー体験を提供しています。将来的に進捗表示の実装方法が確立されれば、その時点で移行を検討できます。

このハイブリッドアプローチにより、mutation処理は2つのカテゴリに整理されます。+actions.tsxにシンプルなmutation処理を集約し、hooks/にuse SlideGenerationフックを配置します。新規にmutation処理を追加する際は、進捗表示の必要性で判断します。進捗表示が不要なら+actions.tsx、必要ならカスタムフックという基準が明確です。

## 実装コスト見積もり

ハイブリッドアプローチの実装工数は約8時間と見積もられます。内訳は以下の通りです。

アーキテクチャ設計に1時間を割きます。+actions.tsxの構造を決定し、既存のuseSlideGenerationフックとの責任分離を明確化します。\_actionフィールドの命名規則やエラーレスポンスの形式を統一します。

候補選択処理の移行に3時間を割きます。selectCandidateAction関数を実装し、candidate-images-grid.tsxでuseFetcherを使用するように変更します。エラー表示UIを統一し、既存の機能が正しく動作することを確認します。この段階でclientActionの実装パターンが確立されます。

リセット処理の移行に2時間を割きます。resetToOriginalAction関数を実装し、preview-header.tsxを変更します。候補選択で確立したパターンを再利用できるため、実装は迅速です。

移行部分のテストに2時間を割きます。action関数の単体テストを作成し、エッジケース(スライドが見つからない、OPFS書き込み失敗など)を検証します。ブラウザでの統合テストも実施し、既存機能への影響がないことを確認します。

合計8時間の工数により、状態管理の削減、エラーハンドリングの一貫性、型安全性の向上という成果を得られます。一方、進捗表示という重要な機能を損なうことなく、段階的に改善できます。

完全移行を目指す場合、生成処理の移行に6時間、進捗表示の代替実装の検討と実装に追加の時間が必要になり、合計17時間程度の工数になります。また、進捗表示の制約というリスクも高く、ユーザー体験が低下する可能性があります。

## 結論

React Router v7のclientActionパターンは、SlideCraftのeditor mutation処理の保守性を大幅に向上させます。コードの明確性、状態管理の削減、エラーハンドリングの一貫性、型安全性、テスタビリティのすべてにおいて、現状の実装より優れています。

ただし、進捗状態の管理という制約により、完全移行は推奨できません。複数画像の生成中に詳細な進捗を表示することは、ユーザー体験において重要です。この機能を犠牲にしてまで完全移行する価値はありません。

ハイブリッドアプローチにより、両方の利点を享受できます。候補選択とリセット処理をclientActionに移行することで、保守性の向上という成果を得ます。生成処理は現状の実装を維持することで、優れたユーザー体験を保ちます。移行コストは8時間程度であり、リスクも低く、段階的に実装できます。

新規にmutation処理を追加する際は、進捗表示の必要性で判断します。シンプルな処理は+actions.tsxに追加し、複雑な進捗管理が必要な処理はカスタムフックとして実装します。この基準により、コードベース全体の一貫性を保ちながら、適切な技術選択ができます。

レポート作成日: 2025-11-24
作成者: Claude Code
