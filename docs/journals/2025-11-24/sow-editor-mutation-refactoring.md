# Statement of Work: Editor Mutation処理のリファクタリング

作成日: 2025-11-24
プロジェクト: SlideCraft
対象: エディタページのmutation処理改善

## ビジネス価値

現在のエディタページのmutation処理は、カスタムフックに密結合した状態管理により保守性とテスタビリティに課題があります。この作業により、コードベースの保守性を向上させ、将来的な機能追加を容易にします。

保守性の向上により、新しい開発者がコードベースを理解する時間が短縮されます。エラーハンドリングが統一されることで、ユーザーへのフィードバックが一貫し、信頼性が向上します。型安全性の強化により、リファクタリング時のバグ混入リスクが低減します。

## ユーザーストーリー

### ストーリー1: 候補画像選択処理の改善

開発者として、候補画像選択処理のコードを理解しやすくしたい。なぜなら、エラーハンドリングやローディング状態の管理が現在は複数の場所に分散しており、変更時に見落としが発生するリスクがあるからです。

受け入れ条件:

- 候補画像をクリックすると、従来通りプレビューが更新される
- 選択中はボタンが無効化され、ユーザーが重複送信できない
- エラーが発生した場合、統一されたUIでエラーメッセージが表示される
- 選択処理のビジネスロジックが独立した関数として単体テスト可能である
- TypeScriptの型推論により、戻り値の型が自動的に検証される

### ストーリー2: リセット処理の改善

開発者として、オリジナル画像へのリセット処理にエラーハンドリングを追加したい。なぜなら、現在はエラーが発生してもユーザーに通知されず、操作が失敗したことに気づかない可能性があるからです。

受け入れ条件:

- 「元に戻す」ボタンをクリックすると、従来通りオリジナル画像に戻る
- リセット中はボタンが無効化され、処理中であることが明示される
- エラーが発生した場合、ユーザーにエラーメッセージが表示される
- リセット処理のビジネスロジックが独立した関数として単体テスト可能である

### ストーリー3: ドキュメント整備

開発者として、React Router v7のaction実装パターンを参照できるドキュメントが欲しい。なぜなら、将来的に新しいmutation処理を追加する際、一貫したパターンで実装したいからです。

受け入れ条件:

- React Router v7のclientActionとactionの違いが説明されている
- useFetcher、Form、useSubmitの使い分け基準が明確である
- SlideCraft固有の実装パターン（\_action分岐、エラーハンドリング）が文書化されている
- 実装例がコードとともに示されている

## スコープ

### 含まれるもの

候補画像選択処理のclientActionへの移行。action関数の実装、コンポーネントのuseFetcher化、エラーハンドリングの統一、単体テストの作成が含まれます。

オリジナル画像へのリセット処理のclientActionへの移行。action関数の実装、ローディング状態の追加、エラー表示の追加、単体テストの作成が含まれます。

React Router v7 action実装ガイドの作成。clientActionとactionの違い、実装パターン、ベストプラクティスが含まれます。

既存機能への影響がないことを確認する回帰テスト。画像選択、リセット、プレビュー更新、候補一覧表示の動作確認が含まれます。

### 含まれないもの

AI生成処理のclientActionへの移行は含まれません。進捗表示の実装に制約があり、ユーザー体験を損なうリスクがあるため、現状のuseSlideGenerationフックを維持します。

loaderでのスライドデータ読み込みは含まれません。現在はコンポーネント内で直接OPFSから読み込んでおり、この部分の変更は別タスクとして扱います。

楽観的UI（useOptimistic）の実装は含まれません。基本的なclientAction実装が安定した後、将来的な改善として検討します。

## 技術的アプローチ

mutation処理をルートの+actions.tsxファイルに集約します。\_actionフィールドで処理を分岐し、各処理を独立した関数として実装します。すべてのaction関数は成功時に`{ success: true, ...data }`、エラー時に`{ error: string }`を返す統一された形式を使用します。

コンポーネントではuseFetcherフックを使用してactionを呼び出します。fetcher.Formでフォームを送信し、fetcher.stateでローディング状態を監視し、fetcher.dataでactionの結果にアクセスします。エラー表示は統一されたAlertコンポーネントを使用します。

action関数は純粋な非同期関数として実装し、単体テストで検証します。FormDataを作成し、関数を呼び出し、戻り値を検証するシンプルなテストパターンを使用します。成功ケース、エラーケース、エッジケースを網羅します。

## 成功基準

すべてのユーザーストーリーの受け入れ条件を満たしていること。既存機能が正しく動作し、ユーザー体験が損なわれていないこと。

action関数の単体テストがすべて成功すること。成功ケース、バリデーションエラー、ランタイムエラー、エッジケースを含みます。

エラーハンドリングが統一されていること。すべてのmutation処理で同じパターンのエラー表示が使用されていること。

型安全性が向上していること。action関数の戻り値が自動推論され、コンポーネント側でコンパイル時に型チェックされること。

ドキュメントが完備されていること。実装ガイドが作成され、新しい開発者が参照できる状態になっていること。

## リスクと制約

進捗表示の制約があります。clientActionはリクエスト-レスポンスモデルのため、AI生成処理の途中経過を返せません。このため、生成処理は現状維持とします。

Revalidationの制約があります。現在loaderはプロジェクトメタデータのみを読み込んでおり、スライドデータは読み込んでいません。このため、Revalidationの自動同期の恩恵を完全には受けられません。将来的な改善として、loaderでのスライドデータ読み込みを検討します。

既存機能への影響リスクがあります。mutation処理の実装方法を大きく変更するため、既存機能が正しく動作することを慎重に確認する必要があります。段階的な移行とテストにより、このリスクを軽減します。

## 見積もり

合計工数: 8時間

内訳:

- アーキテクチャ設計と準備: 1時間
- 候補選択処理の移行と単体テスト: 3時間
- リセット処理の移行と単体テスト: 2時間
- 回帰テストとドキュメント整備: 2時間

この見積もりには、コードレビューやバグ修正の時間は含まれていません。予期しない問題が発生した場合、追加の時間が必要になる可能性があります。

## 実装の段階

第1段階として、+actions.tsxファイルを作成し、基本構造を実装します。clientAction関数と\_actionフィールドによる分岐パターンを確立します。

第2段階として、候補選択処理を移行します。selectCandidateAction関数を実装し、candidate-images-grid.tsxをuseFetcher化します。エラーハンドリングを統一し、単体テストを作成します。既存機能が正しく動作することを確認します。

第3段階として、リセット処理を移行します。resetToOriginalAction関数を実装し、preview-header.tsxを更新します。エラー表示を追加し、単体テストを作成します。

第4段階として、回帰テストを実施します。すべてのmutation処理が正しく動作すること、エラーハンドリングが統一されていること、型安全性が向上していることを確認します。

最終段階として、ドキュメントを整備します。実装パターンをまとめ、将来の開発者が参照できるガイドを作成します。

## 完了の定義

すべてのユーザーストーリーの受け入れ条件が満たされている。action関数の単体テストがすべて成功している。回帰テストで既存機能が正しく動作することを確認している。エラーハンドリングが統一されている。型安全性が向上し、TypeScriptのコンパイルエラーがない。実装ガイドが作成され、チームメンバーがレビューしている。

コードがmainブランチにマージされ、本番環境にデプロイ可能な状態になっている。

作成者: Claude Code
承認者: （ユーザー承認待ち）
