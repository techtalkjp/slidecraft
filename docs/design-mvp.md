# SlideCraft MVP 設計

## 背景と目的

referenceディレクトリに配置されたslidegeniusは、PDFスライドをアップロードしてAIで各ページを再生成できる単一ページアプリケーションである。このアプリケーションの核心的な価値は、プレゼンテーション資料の各スライドに対してプロンプトを入力することで、AIが視覚的な改善案を複数生成し、その中から選択して適用できる点にある。

SlideCraftは、この機能をReact Router v7の利点を活かしながら再構築する。React Routerによる型安全なルーティング、shadcn/uiによる洗練されたUIコンポーネント、そしてVercel AI SDKを活用したストリーミング対応のAI統合を通じて、より保守性とユーザー体験に優れたアプリケーションを実現する。

## アーキテクチャ方針

slidegeniusは全ての状態をReactのuseStateで管理し、単一コンポーネント内で完結する設計だった。これは小規模なプロトタイプとしては機能するが、機能追加や状態の永続化を考えると限界がある。

SlideCraftでは、React Router v7のloaderとactionを活用することで、状態管理とデータフローを明確に分離する。スライドデータはブラウザのOrigin Private File System（OPFS）に永続化し、ページ遷移やリロード後も作業を継続できるようにする。OPFSは大容量のバイナリデータに適しており、画像を多数扱うこのアプリケーションに最適である。これにより、ユーザーは長時間にわたってスライドを編集できる。

また、react-router-auto-routesを導入することで、ルート定義をファイルシステムベースで管理する。これにより、機能追加時にルート設定ファイルを手動で編集する必要がなくなり、コロケーションの原則に従ってコンポーネントと関連ファイルを同じディレクトリに配置できる。

## 最小限の機能範囲

MVPとして実装する機能は以下の通りである。

**PDFアップロード画面**は、ユーザーがスライドデッキをドラッグ&ドロップまたはファイル選択でアップロードする入り口となる。PDFの各ページをブラウザ内でCanvasに変換し、画像データとして保持する。この処理は全てクライアントサイドで完結し、サーバーにファイルを送信しない。処理完了後は自動的にエディター画面に遷移する。

**エディター画面**は、左サイドバーにスライド一覧のサムネイル、中央にメインプレビューエリア、右パネルに編集コントロールを配置する3カラムレイアウトとする。これはslidegeniusと同じ構成だが、shadcn/uiのコンポーネントを用いることでアクセシビリティとレスポンシブ性を向上させる。

**スライド生成機能**では、ユーザーがプロンプトを入力して生成ボタンを押すと、現在選択中のスライドに対してVercel AI SDKを通じてNano Banana Proモデルが画像のバリエーションを生成する。生成された候補はサムネイルとして右パネルに表示され、クリックすることでメインプレビューに適用される。生成履歴は保持され、いつでも過去の候補に戻せる。

**エクスポート機能**は、現在適用されているスライド画像を全て結合してPDFとしてダウンロードする。これによりユーザーは編集後のスライドデッキを保存できる。

## ルート構成

react-router-auto-routesの規約に従い、以下のルート構造を採用する。

`routes/index.tsx`はルートパスに対応し、PDFアップロード画面を表示する。スライドデータがOPFSに存在しない場合は新規アップロードを促し、存在する場合はエディター画面へのリンクを表示する。

`routes/editor.tsx`はエディター画面を表示する。このルートのloaderはOPFSからスライドデータを読み込み、存在しない場合はルートパスにリダイレクトする。

`routes/settings.tsx`はAPI設定画面を表示する。Google Gemini APIキーの入力と保存を行う。ヘッダーの設定ボタンまたはAPIキー未設定時に自動的に表示される。

## データモデル

slidegeniusの型定義をベースとしつつ、React Routerの型システムに適合させる。

`Slide`型は、スライドの一意識別子、ページインデックス、元画像のdata URL、現在適用中の画像data URL、生成された候補の配列、最後に使用したプロンプトを保持する。この構造により、ユーザーは元の状態に戻したり、複数の候補を比較したりできる。

`GeneratedImage`型は、生成された画像の識別子、data URL、使用したプロンプト、生成時刻を持つ。これにより生成履歴を時系列で管理できる。

## AI統合

slidegeniusと同様に、Google Gemini APIを直接使用する。ただし、APIキーの管理方法を改善し、ユーザーが自分のAPIキーを設定する方式を採用する。これにより、ユーザーは自分のGoogleアカウントでAPIキーを取得し、使用量とコストを直接管理できる。

APIキーは初回起動時にユーザーに入力してもらい、ブラウザのlocalStorageに保存する。ヘッダーに設定ボタンを配置し、いつでもAPIキーを変更できるようにする。APIキーが未設定の場合は、編集機能を使用する前に設定画面を表示する。

画像生成はクライアントサイドで実装する。ユーザーがプロンプトを入力して生成ボタンを押すと、保存されたAPIキーを使用してGoogle Gemini APIを直接呼び出す。生成された画像データはOPFSに保存し、候補リストに追加する。この方式により、サーバーサイドの実装が不要になり、静的サイトとしてデプロイできる。

生成中の状態表示には、Reactのローカルステートを使用してローディング状態を管理し、プログレスインジケーターを表示する。エラーハンドリングでは、APIキーの不正、レート制限、ネットワークエラーなど、各種エラーに応じた適切なメッセージを表示する。

## UI実装方針

shadcn/uiのButtonコンポーネント、Cardコンポーネント、Textareaコンポーネントなどを使用し、一貫性のあるデザインシステムを構築する。TailwindCSS v4のカスタムプロパティを活用することで、ダークモード対応やテーマ切り替えを将来的に追加しやすくする。

アップロード画面のドラッグ&ドロップ領域は、ドラッグ中の視覚的フィードバックを重視する。slidegeniusと同様に、ドラッグ状態に応じて背景色とボーダーを変化させ、ユーザーに操作の受け付け状態を明示する。

エディター画面のサイドバーは、スライドのサムネイルを縦スクロールで表示する。選択中のスライドは青色のリングで強調し、編集済みのスライドには小さなバッジを付ける。これによりユーザーは全体の編集状況を一目で把握できる。

## 状態の永続化

Origin Private File System（OPFS）を使用してスライドデータを保存する。OPFSはlocalStorageの容量制限を超えて大容量のデータを扱え、画像のようなバイナリデータの保存に適している。PDFアップロード時と各スライド更新時に自動保存することで、ユーザーは明示的な保存操作を意識せずに作業を続けられる。

ファイル構造は`/slidecraft/`サブディレクトリ以下にアプリケーションデータを配置する。`/slidecraft/slides.json`にメタデータ（スライドID、ページインデックス、プロンプト履歴など）を保存し、各スライドの画像データは`/slidecraft/images/{slideId}/original.png`、`/slidecraft/images/{slideId}/current.png`、`/slidecraft/images/{slideId}/generated/{generatedId}.png`として個別に保存する。この構造により、OPFS内で他のアプリケーションデータと名前空間を分離し、大量の画像データを効率的に管理できる。

OPFSはFile System Access APIの一部であり、非同期APIを提供する。読み書き操作は全てPromiseベースで実装し、React RouterのloaderとactionでawaitすることでSSRとの互換性を保つ。ブラウザ対応はChrome/Edge 86+、Safari 15.2+と十分に広い。

## エラーハンドリング

PDF処理の失敗、AI生成の失敗、OPFSへの書き込み失敗など、複数の失敗ケースが想定される。これらはReact RouterのErrorBoundaryで捕捉し、ユーザーフレンドリーなエラーメッセージを表示する。

特にAI生成の失敗は頻繁に発生する可能性があるため、リトライボタンと共にエラーの詳細をログに記録し、デバッグを容易にする。OPFSの容量制限に達した場合は、古い生成候補の削除を促すメッセージを表示する。

## 実装の優先順位

最初にルート構成とデータモデルの型定義を行う。次にOPFSのユーティリティ関数（読み込み、書き込み、削除）を実装し、動作を確認する。その後PDFアップロード機能を実装し、ブラウザ内でのPDF→画像変換とOPFSへの保存を確認する。

エディター画面の基本レイアウトを構築し、サイドバーとメインプレビューの連携を実装する。API設定画面を実装し、localStorageへのAPIキー保存機能を追加する。Gemini API呼び出しユーティリティを実装し、画像生成機能を統合する。最後にPDFエクスポート機能を追加する。

この順序により、各段階で動作確認しながら段階的に機能を追加できる。
